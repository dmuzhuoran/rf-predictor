
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cluster Prediction</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; max-width: 900px; margin: auto; }
    h1 { color: #333; }
    label { display: block; margin-top: 10px; }
    input { width: 100%; padding: 6px; margin-top: 2px; }
    button { margin-top: 15px; padding: 10px 20px; font-size: 16px; }
    #result, #batchResult { margin-top: 20px; font-weight: bold; color: green; }
  </style>
</head>
<body>
  <h1>Cluster Prediction</h1>

  <form id="predictForm">
    <div id="inputs"></div>
    <button type="submit">Predict</button>
  </form>

  <div id="result"></div>

  <hr>
  <h2>Batch Prediction (Upload CSV)</h2>
  <input type="file" id="csvFile" accept=".csv">
  <button id="uploadBtn">Upload & Predict</button>
  <div id="batchResult"></div>

  <script>
    let model = null;
    let scaler = null;
    let imputer = null;
    let feature_names = [];

    document.addEventListener("DOMContentLoaded", async function () {
      try {
        model = await fetch("model.json").then(res => res.json());
        scaler = await fetch("scaler.json").then(res => res.json());
        imputer = await fetch("imputer.json").then(res => res.json());

        if (!scaler.mean || !scaler.scale) throw new Error("Invalid scaler format.");
        feature_names = Object.keys(scaler.mean);

        const inputDiv = document.getElementById("inputs");
        feature_names.forEach(name => {
          const label = document.createElement("label");
          label.textContent = name + ":";
          const input = document.createElement("input");
          input.name = name;
          input.placeholder = name;
          inputDiv.appendChild(label);
          inputDiv.appendChild(input);
        });

      } catch (err) {
        alert("❌ Failed to load model or parameters: " + err.message);
        return;
      }

      function imputeMissing(value, mean) {
        return value === "" || value === null || isNaN(value) ? mean : parseFloat(value);
      }

      function standardize(value, mean, std) {
        return std === 0 ? 0 : (value - mean) / std;
      }

      function argMax(arr) {
        return arr.indexOf(Math.max(...arr));
      }

      function predictSingle(inputData) {
        if (!model || !scaler || !imputer) throw new Error("Model not loaded.");

        const imputed = feature_names.map(name =>
          imputeMissing(inputData[name], imputer[name])
        );

        const standardized = imputed.map((val, i) =>
          standardize(val, scaler.mean[feature_names[i]], scaler.scale[feature_names[i]])
        );

        const class_votes = {};
        for (let tree of model.trees) {
          const nodes = tree.nodes;
          let node_index = 0;

          while (true) {
            const node = nodes[node_index];
            if (node.feature === -2) {
              const pred = argMax(node.value);
              class_votes[pred] = (class_votes[pred] || 0) + 1;
              break;
            }
            const val = standardized[node.feature];
            node_index = val <= node.threshold ? node.left : node.right;
          }
        }

        return Object.entries(class_votes).sort((a, b) => b[1] - a[1])[0][0];
      }

      document.getElementById("predictForm").addEventListener("submit", function (e) {
        e.preventDefault();
        const inputData = {};
        const inputs = document.querySelectorAll("form input");
        inputs.forEach(input => {
          inputData[input.name] = input.value.trim();
        });

        try {
          const prediction = predictSingle(inputData);
          document.getElementById("result").innerText = "Predicted Cluster: Cluster " + prediction;
        } catch (error) {
          document.getElementById("result").innerText = "❌ Prediction failed: " + error.message;
        }
      });

      document.getElementById("uploadBtn").addEventListener("click", function () {
        const file = document.getElementById("csvFile").files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
          const lines = e.target.result.trim().split("\n");
          const headers = lines[0].split(",");
          const output = [];

          for (let i = 1; i < lines.length; i++) {
            const row = lines[i].split(",");
            const inputData = {};
            headers.forEach((h, idx) => {
              inputData[h.trim()] = row[idx].trim();
            });

            try {
              const pred = predictSingle(inputData);
              output.push(`Row ${i}: Cluster ${pred}`);
            } catch (err) {
              output.push(`Row ${i}: Error - ${err.message}`);
            }
          }

          document.getElementById("batchResult").innerHTML = output.map(r => `<div>${r}</div>`).join("");
        };
        reader.readAsText(file);
      });
    });
  </script>
</body>
</html>

